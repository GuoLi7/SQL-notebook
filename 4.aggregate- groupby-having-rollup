-- aggregate functions 聚合函数
SELECT
   MAX(invoice_total) AS highest,
   MIN(invoice_total) AS lowest,
   AVG(invoice_total) AS average,
   SUM(invoice_total*1.1) AS total,
   COUNT(DISTINCT client_id) AS total_records  -- dictinct 无重复id
FROM invoices
WHERE invoice_date > '2019-07-01';

-- Group By
SELECT 
    date,
    pm.name AS payment_method,
    SUM(amount) AStotal_payments
FROM payments p
JOIN payment_methods pm
    ON p.payment_method=pm.payment_method_id
GROUP BY date, payment_method
ORDER BY date;

-- Having 分组后筛选数据 与where相对
SELECT 
    c.customer_id,
    c.first_name,
    c.state,
    SUM(oi.quantity*oi.unit_price) AS total_spend
FROM customers c
JOIN orders o 
    ON c.customer_id=o.customer_id
JOIN order_items oi
    ON o.order_id=oi.order_id
WHERE state='VA' or state='MA'
GROUP BY   
    c.customer_id,
    c.first_name
HAVING total_spend>100;

-- ROLLUP
SELECT
pm.name AS method,
SUM(amount)
FROM payments p
JOIN payment_methods pm
  ON p.payment_method=pm.payment_method_id
GROUP BY method WITH ROLLUP


-- complex queries 复杂查询
-- subqueries 子查询
-- find products that are more expensive than lettuce(id=3)
SELECT *
FROM products 
WHERE unit_price>(
     SELECT unit_price
     FROM products 
     WHERE product_id=3
);

-- in aql_hr database 
-- find emplyees whose earn more than average 
SELECT *   
FROM  employees
WHERE salary >(
    SELECT AVG(salary)
    FROM  employees
);

-- IN Operator 查询从没有被订购过的商品
SELECT *
FROM products 
WHERE  product_id NOT IN(
    SELECT DISTINCT product_id
    FROM  order_items
);

-- find clients without invoices
SELECT *
FROM  clients
WHERE client_id NOT IN (
    SELECT DISTINCT client_id
    FROM  invoices
);

-- subquery VS joins
-- find customers who have ordered lettuce (id=3)
-- select customer _id, first_name, last_name
-- subsquery 
SELECT customer_id,first_name, last_name
FROM customers
WHERE customer_id IN(
  SELECT customer_id
  FROM orders
  WHERE order_id IN (
      SELECT order_id 
      FROM order_items
      WHERE product_id=3
  ));
  
SELECT customer_id,first_name, last_name
FROM customers c
WHERE c.customer_id IN (
SELECT customer_id
FROM order_items oi
JOIN orders o USING(order_id)
WHERE oi.product_id=3);
  
-- joins
SELECT DISTINCT customer_id, first_name, last_name
FROM customers c 
JOIN orders o  USING (customer_id)
JOIN order_items oi USING (order_id)
WHERE oi.product_id=3;

-- The ALL Keyword
-- select invoices larger than all invoices of client 3
SELECT *
FROM invoices
WHERE invoice_total>(
SELECT MAX(invoice_total)
FROM invoices
WHERE client_id=3);
-- another way-ALL
SELECT *
FROM invoices
WHERE invoice_total> ALL(
  SELECT invoice_total
  FROM invoices
  WHERE client_id=3)
  
 -- ANY operator ALL 大于最大值 ANY/SOME大于最小值
  
  -- correlated squeries 相关子查询 自己的一个元素和自己的其他元素相比
-- select emplyees whose salary is above the average 
-- in their office 每位员工的office不一样 要用 office_id 分类
SELECT *
FROM employees e
WHERE salary > (
  SELECT AVG(salary)
  FROM employees
  WHERE office_id=e.office_id
);

-- get invoices that are larger than the clients average invoice amount
-- 注意 一位client可能有多张invoices
SELECT *
FROM invoices i
WHERE invoice_total> (
   SELECT AVG(invoice_total)
   FROM invoices
   WHERE client_id=i.client_id
);

-- EXISTS Operator  loop + if
-- select clients that have an invoice

-- 该方法run括号内会产生大量数据集
SELECT *
FROM clients 
WHERE client_id IN (
  SELECT DISTINCT invoice_id
  FROM invoices
);

SELECT *
FROM clients c
WHERE EXISTS(
  SELECT client_id
  FROM invoices
  WHERE client_id=c.client_id
);

-- find the products that have never been ordered
SELECT *
FROM products p
WHERE NOT EXISTS (
  SELECT DISTINCT product_id
  FROM  order_items o
  WHERE p.product_id=o.product_id
);

-- subqueries in the SELECT caluse 
SELECT 
    invoice_id, 
    invoice_total,
    (SELECT AVG(invoice_total)
     FROM invoices ) AS invoice_average, 
     invoice_total - (SELECT invoice_average ) AS difference 
FROM invoices

